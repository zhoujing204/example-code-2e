from array import array
import math

class Vector2D:
    """A vector2D class
    
    
    """
    
    typecode = 'd' # <1>
    
    #  This attribute is used for pattern matching
    __match_args__ = ('x', 'y') 
    
    __slots__ = ('__x', '__y')
    
    def __init__(self, x, y):
        self.__x = float(x)
        self.__y = float(y)
        
    @property
    def x(self):
        return self.__x
    
    @property
    def y(self):
        return self.__y
        
    def __iter__(self):
        return (i for i in (self.x, self.y)) # <2>
    
    def __repr__(self):
        class_name = type(self).__name__
        return '{}({!r}, {!r})'.format(class_name, *self) # <3>  
    
    def __str__(self) -> str:
        return str(tuple(self)) # <4>
    
    def __bytes__(self):
        """Generate bytes from class instance.
        Don't forget [ ] around ord('d'). 
        Bytes of a list are shorter than 
        a string of same length and contents.

        Returns:
            bytes: generated bytes
        """
        return (bytes([ord(self.typecode)]) + # <5>
                bytes(array(self.typecode, self))) # <6>
    
    # The classmethod decorator modifies a method so it can be 
    # called through the class instead of an instance.
    @classmethod       
    def frombytes(cls, octets):
        """Converts a typecode byte and octets into a Vector2D instance.
        No self argument; instead, the class itself is passed as cls.
        <1> Read the typecode from the first byte.
        <2> Create a memoryview from the octets binary sequence and use 
        the typecode to cast it.
        <3> Unpack the memoryview resulting from casting into the pair of
        arguments needed for the constructor.

        Args:
            octets (_type_): bytes of a Vector2D instance 

        Returns:
            Vector2D: Vector2D instance
        """
        typecode = chr(octets[0]) # <1>
        memv = memoryview(octets[1:]).cast(typecode) # <2>
        return cls(*memv) # <3>
    
    def __eq__(self, other):
        return tuple(self) == tuple(other) # <7>
    
    def __hash__(self) -> int:
        return hash((self.x, self.y))
    
    def __abs__(self):
        return math.hypot(self.x, self.y) # <8>
    
    def __bool__(self):
        return bool(abs(self)) # <9>
    
    def angle(self):
        return math.atan2(self.y, self.x)
    
    def __format__(self, fmt_spec=''):
        if fmt_spec.endswith('p'):
            fmt_spec = fmt_spec[:-1]
            coords = (abs(self), self.angle())
            outer_fmt = '<{}, {}>'
        else:
            coords = self
            outer_fmt ='({}, {})'
        components = (format(c, fmt_spec) for c in coords)
        return outer_fmt.format(*components)
    
        
    
class ShortVector2d(Vector2D):
    typecode = "f"
    
# sv1 = ShortVector2d(1/11, 1/27)
# print(repr(sv1))
# print(len(bytes(sv1)))
# print(bytes(sv1))
    

    

    